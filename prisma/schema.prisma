generator client {
  provider = "prisma-client-js"
  seed     = "ts-node prisma/seed.ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int            @id @default(autoincrement())
  name            String         @db.VarChar(100)
  username        String         @unique @db.VarChar(50)
  phone           String         @unique @db.VarChar(20)
  password        String
  role            Role
  address         String?        @db.VarChar(255)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  notifications   Notification[]
  createdOrders   Order[]        @relation("OrderCreatedBy")
  orders          Order[]        @relation("UserOrders")
  createdPayments Payment[]      @relation("PaymentCreatedBy")
  payments        Payment[]      @relation("UserPayments")
}

model Category {
  id          Int       @id @default(autoincrement())
  name        String    @db.VarChar(100)
  code        String    @unique @db.VarChar(50)
  description String?   @db.VarChar(255)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  products    Product[]
}

model Product {
  id          Int              @id @default(autoincrement())
  categoryId  Int
  name        String           @db.VarChar(150)
  description String?
  baseCode    String           @db.VarChar(50)
  photo       String?          @db.VarChar(255)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  orderItems  OrderItem[]
  category    Category         @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  variants    ProductVariant[]
  
  @@unique([baseCode, categoryId])
  @@index([categoryId])
}

// Variant types like "Bahan", "Cetak", "Laminasi"
model ProductVariant {
  id          Int                   @id @default(autoincrement())
  productId   Int
  variantName String                @db.VarChar(100)  // e.g., "Bahan", "Cetak", "Laminasi"
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  product     Product               @relation(fields: [productId], references: [id], onDelete: Cascade)
  options     ProductVariantOption[]  // Options for this variant type
  
  @@index([productId])
}

// Options like "210", "230", "1 Sisi", "Doff" etc. with prices
model ProductVariantOption {
  id          Int                   @id @default(autoincrement())
  variantId   Int
  optionName  String                @db.VarChar(100)  // e.g., "210", "230", "1 Sisi", "Doff"
  price       Int                   // actual price for this option
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  variant     ProductVariant        @relation(fields: [variantId], references: [id], onDelete: Cascade)
  orderItems  OrderItemOption[]     // Link to order items that selected this option
  
  @@index([variantId])
}

// Link selected options to order items
model OrderItemOption {
  id            Int                   @id @default(autoincrement())
  orderItemId   Int
  optionId      Int
  optionName    String                // Store name for historical reference
  price         Int                   // Store price for historical reference
  createdAt     DateTime              @default(now())
  orderItem     OrderItem             @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  option        ProductVariantOption? @relation(fields: [optionId], references: [id])
  
  @@index([orderItemId])
  @@index([optionId])
}

model Order {
  id             Int            @id @default(autoincrement())
  userId         Int
  createdById    Int?
  orderNumber    String         @unique @db.VarChar(50)
  status         OrderStatus    @default(pending)
  shippingMethod ShippingMethod
  paymentMethod  PaymentMethod
  paymentStatus  PaymentStatus  @default(pending)
  totalAmount    Int
  notes          String?        @db.VarChar(500)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  notifications  Notification[]
  createdBy      User?          @relation("OrderCreatedBy", fields: [createdById], references: [id])
  user           User           @relation("UserOrders", fields: [userId], references: [id], onDelete: Cascade)
  orderItems     OrderItem[]
  payments       Payment[]

  @@index([userId])
  @@index([status])
  @@index([paymentStatus])
}

// Updated OrderItem model
model OrderItem {
  id        Int                 @id @default(autoincrement())
  orderId   Int
  productId Int
  qty       Int
  price     Int                 // Final calculated price from selected options
  subtotal  Int                 // qty * price
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt
  notes     String?             @db.VarChar(500)
  order     Order               @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product   Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
  options   OrderItemOption[]   // Selected options for this order item
  
  @@index([orderId])
  @@index([productId])
}

model Payment {
  id             Int            @id @default(autoincrement())
  orderId        Int
  userId         Int
  createdById    Int?
  method         PaymentMethod
  amount         Int
  status         PaymentStatus  @default(pending)
  transactionRef String?        @db.VarChar(100)
  paidAt         DateTime?
  createdAt      DateTime       @default(now())
  createdBy      User?          @relation("PaymentCreatedBy", fields: [createdById], references: [id])
  order          Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  user           User           @relation("UserPayments", fields: [userId], references: [id], onDelete: Cascade)
  proofs         PaymentProof[]

  @@index([orderId])
  @@index([status])
}

model PaymentProof {
  id         Int      @id @default(autoincrement())
  paymentId  Int
  fileName   String   @db.VarChar(255)
  filePath   String   @db.VarChar(255)
  fileType   String   @db.VarChar(50)
  uploadedAt DateTime @default(now())
  payment    Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model Notification {
  id       Int      @id @default(autoincrement())
  userId   Int
  orderId  Int?
  toNumber String   @db.VarChar(20)
  message  String
  status   String   @db.VarChar(20)
  sentAt   DateTime @default(now())
  order    Order?   @relation(fields: [orderId], references: [id])
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
}

model Expense {
  id          Int             @id @default(autoincrement())
  nominal     Int
  category    ExpenseCategory
  date        DateTime
  description String?         @db.VarChar(255)
  proofFile   String?         @db.VarChar(255)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([category])
  @@index([date])
}

model Setting {
  id                Int     @id @default(1)
  name              String  @db.VarChar(100)
  description       String  @db.VarChar(255)
  logo              String? @db.VarChar(255)
  bankAccountName   String? @db.VarChar(100)
  bankAccountNumber String? @db.VarChar(50)
  bankCode          String? @db.VarChar(10)
  bankName          String? @db.VarChar(100)
  qrisImage         String? @db.VarChar(255)
}

enum Role {
  admin
  staff
  customer
}

enum OrderStatus {
  pending
  processing
  finished
  canceled
}

enum PaymentMethod {
  transfer
  qris
  cash
}

enum PaymentStatus {
  pending
  confirmed
  failed
  refunded
}

enum ShippingMethod {
  pickup
  delivery
}

enum ExpenseCategory {
  operasional
  marketing
  gaji
  lainnya
}
